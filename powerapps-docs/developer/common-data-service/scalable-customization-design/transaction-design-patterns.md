---
title: 'スケーラブル カスタマイズ設計: トランザクション デザイン パターン (アプリ用 Common Data Service) | Microsoft Docs'
description: '4 つめのトピック。 '
ms.custom: ''
ms.date: 11/18/2018
ms.reviewer: ''
ms.service: powerapps
ms.topic: article
author: rogergilchrist
ms.author: jdaly
manager: ryjones
search.audienceType:
  - developer
search.app:
  - PowerApps
  - D365CE
---
# <a name="scalable-customization-design-transaction-design-patterns"></a>スケーラブル カスタマイズ設計: トランザクション デザイン パターン

> [!NOTE]
> これは、スケーラブル カスタマイズ設計に関する 4 つめのトピックです。 最初から始めるには [アプリ用 Common Data Service におけるスケーラブル カスタマイズ設計](overview.md) を参照してください。

このセクションでは、回避または最小化する設計パターンとその影響について説明します。 それぞれの設計パターンは、解決されるビジネス上の課題という観点から考慮する必要があり、調査するための選択肢として役立ちます。

## <a name="dont-avoid-locking"></a>ロックを避けないようにしてください。

ロックは SQL Server と アプリ用 CDS の非常に重要なコンポーネントであり、システムの正常な動作と一貫性を保つために不可欠です。 このため、特にスケールで、デザインへの影響を理解することが重要です。

## <a name="transaction-usage-nolock-hint"></a>トランザクションの使用: Nolock のヒント

ビューで頻繁に使用されるアプリ用 CDS プラットフォームの 1 つの機能は、クエリを nolock のヒントで実行できることを指定する機能です。これにより、このクエリにロックが不要であることをデータベースに伝えます。 

ビューは、ビューおよびそれ以降のアクションのトップに間に直接リンクがないため、この方法を使用します。 そのユーザー、またはその間にいる他のユーザーによって、他にも多くのアクティビティが発生する可能性があります。ビューに表示されるデータのテーブル全体をロックして、ユーザーが移動するまで待機するのは実用的ではなく、利益もありません。 

大規模なデータセットに対するクエリは、そのデータのいずれかと対話しようとしている他のユーザーに影響を与える可能性があるため、ロックが不要であると指定できるということは、システムのスケーラビリティに対して大きなメリットがあります。 

SDK を介してプラットフォームのクエリを作成するときに、nolock が使用できるように指定することは有益です。 これは、このクエリがデータベース内で読み取りロックを取得する必要がないことを認識していることを示しています。 クエリに特に有効なのは、次の場合です。

- スコープのデータ全体があるとき
- 競合の激しいリソースでクエリが実行されたとき
- シリアル化されたは重要ではないとき

前述の自動付番のロックの例のように、後の操作が結果の変更に依存しない場合は、Nolock を使用しないでください。 

それが役に立つ可能性のあるシナリオの例としては、電子メールが既存のケースに関連しているかどうかを判断することが挙げられます。 他のユーザーが新しいケースを作成するのをブロックして、電子メールが確実に作成されないようにすることは、一貫性のコントロールに対して有益だとは言えないでしょう。 

代わりに、関連するケースにクエリを実行して既存のケースに電子メールを添付するか、他のケースを生成できるようにする一方で新しいケースを作成するといった、妥当な努力をするほうがより適切です。 特に、これら 2 つのアクションの間のタイミングには固有のリンクがないため、電子メールが数秒早く受信してリンクが検出されなかった可能性があります。 

ロックのヒントが特定のシナリオに有効であるかどうかは、通常、競合が発生する可能性と影響、および取得と後続の間にあるアクションの一貫性を保証しないことによるビジネス上の影響の判断に基づきます。 ロックを回避してもビジネス上の影響が生じない場合は、nolock を使用することが最適化の良い選択肢となります。 ビジネスに潜在的な影響がある場合は、その影響について、ロックを回避することによるパフォーマンスと拡張性のメリットを比較検討することができます。 

## <a name="consider-order-of-locks"></a>ロックの順番を考える

ブロックの影響を減らす、特にデッドロックを回避するのに役立つ可能性があるもう 1 つの方法は、実装内でのロックの順序付けに対する一貫性のあるアプローチです。 

単純で一般的な例は、ユーザーのグループを更新または対話するときです。 関連ユーザーを更新するリクエスト (チームへのメンバーの追加やアクティビティ内のすべての参加者の更新など) がある場合に、2 つの同時アクティビティが同じユーザーを更新しようとすると、次のような動作になる可能性があり、その結果、デッドロックが発生します。 

- トランザクション A はユーザー X を更新してからユーザー Y を更新しようとします
- トランザクション B はユーザー Y を更新してからユーザー X を更新しようとします

両方の要求が同時に開始されるため、トランザクション A はユーザー X をロックし、トランザクション B はユーザー Y をロックすることができますが、各ユーザーが他のユーザーをロックしようとするとすぐにブロックされ、その後デッドロックが発生します。 

![問題の例: デッドロック トランザクション](media/order-of-locks-example-1.png)

一貫した方法でアクセスするリソースを順番に並べるだけで、多くのデッドロックされる状況を防ぐことができます。 順序付けメカニズムは、一貫性があり、できるだけ効率的に実行できる限り、多くの場合重要ではありません。 たとえば、名前または GUID でユーザーを並べ替えることで、少なくともデッドロックを回避する一定レベルの一貫性を確保できます。

このアプローチを使用するシナリオでは、トランザクション A はユーザー X を取得しますが、トランザクション B もユーザー Y よりもユーザー X を取得しようとします。 これは、トランザクション A が完了するまでトランザクション B がブロックされることを意味しますが、このシナリオではデッドロックが回避され、正常に完了します。

![一貫した方法でリソースを順序付けることによってデッドロックを回避する](media/order-of-locks-example-2.png)

より複雑で効率的なシナリオでは、最初に最も一般的に参照されていないユーザーをロックし、最後により頻繁に参照されているユーザーをロックすることです。これにより、次の設計パターンにつながります。

## <a name="hold-contentious-locks-for-shortest-period"></a>最短期間、競合するロックを保持する

自動付番アプローチのような、ロックが必要な競合の激しいリソースの存在を回避する方法がないというシナリオがあります。 その場合、ブロックの問題を完全に回避することはできませんが、最小限に抑えることはできます。

競合の激しいリソースがある場合は、プロセス内の機能的に論理的なポイントにそのリソースとの対話を含めないで、できるだけトランザクションの終わりで、そのトランザクションとの対話を行うことをお勧めします。 

この方法では、まだこのリソースをある程度ブロックすることになりますが、リソースがロックされる時間が短縮されるため、リソースを待っている間に他の要求がブロックされる可能性と時間が減少します。 

![最短期間、競合するロックを保持する](media/hold-contentious-locks-for-shortest-period.png)

## <a name="reduce-length-of-transactions"></a>対話の長さを減らす

同様に、ロックは、2つのプロセスが同時に同じリソースにアクセスする必要がある場合にのみブロックの問題になります。 ロックを保持するトランザクションが短くなればなるほど、2つのプロセスが同じリソースにアクセスしたとしても、それらがまったく同時に同じリソースを必要とし、衝突を引き起こす可能性は低くなります。 トランザクションの保持時間が短いほど、ブロックが問題になる可能性は低くなります。

次の例では、同じロックが選択されますが、トランザクション内の他の処理は、トランザクションの全体の長さが拡張され、同じリソースに対する要求が重複することを意味します。 つまり、ブロックが発生し、各リクエストは全体的に遅くなるということです。

![問題の例: トランザクションが長すぎたことによるブロック](media/reduce-length-of-transactions.png)

トランザクションの全長を短くすることで、最初のトランザクションは2番目の要求が開始される前にロックを完了して解放します。つまり、ブロックがなく、両方のトランザクションが効率的に完了します。 

トランザクションの寿命を延ばすリクエスト内の他のアクティビティは、特に複数のリクエストが重複している場合にブロックの可能性を高め、システムが大幅に遅くなる可能性があります。 

![トランザクションが短くなったため、ブロックが減少](media/reduce-length-of-transactions-1.png)

トランザクションを短くする方法はいくつかあります。

## <a name="optimize-requests"></a>最適化要求

各トランザクションは一連のデータベース要求で構成されています。 各要求ができるだけ高く効率的になされれば、トランザクション全体の長さを減らして競合する可能性を低減します。

各クエリを確認して、以下の事を判断します。

- クエリが、必要なもの、たとえば列、レコード、エンティティ タイプなどを尋ねるだけです。
  - これにより、インデックスを使用してクエリを効率的に処理できる可能性が最大化されます
  - アクセスする必要があるテーブルとリソースの数を減らし、データベース サーバ内の他のリソースのオーバーヘッドを減らし、クエリ時間を短縮します
  - 特に、別のテーブルへの結合が要求があったが、その要求を回避される可能性がある場合や、その要求が不要な場合に、不要なリソースをブロックしないようにします
- クエリを補助するためのインデックスが用意されているか、効率的な方法でクエリを実行しているか、スキャンではなくインデックス シークが行われます

  インデックスを導入しても、基礎となるテーブル内のレコードの作成または更新がロックされるのを避けることはできません。 インデックス自体が変更される可能性があるため、関連レコードが更新されると、インデックス内の項目もロックされます。 インデックスが存在しても、この問題を完全に回避することはできません。

次の例では、関連する案件の取得が最適化されておらず、トランザクション全体の長さが増し、スレッド間でブロックが発生しています。

![最適化されていない関連するサポート案件の取得](media/optimize-requests-1.png)

クエリを最適化することで、クエリの実行にかかる時間が短縮され、衝突の可能性が低くなるため、ブロックが減少します。

![最適化された関連するサポート案件の取得](media/optimize-requests-2.png)

データベース サーバーが可能な限り効率的にクエリを処理できることを確認することで、トランザクションの全体的な時間を大幅に短縮し、ブロックの可能性を減らすことができます。

## <a name="reduce-chain-of-events"></a>イベントのチェーンを削減する

前の例で示したように、関連する一連のイベントの結果はトランザクション時間全体に重大な影響を与えるかもしれないので、ブロックの可能性が生じます。 これは、同期プラグインとワークフローをトリガーし、それが他のアクションをトリガーし、さらに同期プラグインとワークフローをトリガーする場合に特に当てはまります。

同期して発生する長いイベントのチェーンを回避するために、実装を慎重に検討および設計することは、トランザクション全体の長さを短縮するのに役立ちます。 これにより、実行されたロックをより迅速に解放し、ブロックする可能性を減らすことができます。 

また、二次ロックが大きな問題になる可能性も低くなります。 アカウント作成の自動付番の例では、最初の問題は自動付番テーブルへのアクセスです。しかし、多くの異なるアクションが1つのシーケンスで実行されると、関連するユーザー レコードへの更新など、二次ブロックも表面化し始める可能性があります。 複数の競合するリソースが関与すると、ブロックを回避することがさらに難しくなります。 

いくつかのアクティビティが同期または非同期である必要があるかどうかを検討することは、同じアクティビティが達成される一方で初期の影響が少ないという意味です。 特に実行時間が長いアクションや、競合の激しいリソースに依存するアクションの場合は、非同期アクションで実行しメイントランザクションからそれらを分離すると、大きなメリットがあります。 次の自動付番の値で警察犯罪レポートを更新して連続番号スキームを確実に維持するなど、アクションをより広いプラットフォーム ステップで完了または失敗させる必要がある場合、このアプローチは機能しません。 これらのシナリオでは、影響を最小限に抑えるために他のアプローチをとる必要があります。 

次の例が示すように、単純にアクションをプラットフォーム トランザクションの外側で実行することを意味する、いくつかのアクションを非同期プロセスに移動することによって、トランザクションの長さが短くなり、並行処理の可能性が高まることを意味します。

![アクションを非同期プロセスに移動するとトランザクションが短くなります](media/reduce-chain-of-events.png)

## <a name="avoid-multiple-updates-to-the-same-record"></a>同じレコードに対する複数の更新を避ける

複数レイヤーの機能アクティビティを設計するときは、必要なアクションを論理的で簡単に従うことができるアクティビティ フローに分割することをお勧めしますが、多くの場合、これによって同じレコードに対する、複数の別々の更新が発生します。
 
ケースを処理するシナリオでは、最初に提起された顧客に基づいて既存の所有者でケースを更新し、その後、その顧客に自動的に通信を送りケースに対する最終連絡日を更新する別のプロセスを待機することは、機能的には完全に論理的です。 

ただし、これは、次のように、アプリ用 CDS が同じレコードを更新するための複数の要求があることを意味しています。

- 各要求は個別のプラットフォームの更新であり、アプリ用 CDS サーバーに全体的な負荷がかかり、トランザクション全体の長さを増大させるため、ブロックされる可能性が高くなります。
- また、ケース レコードがそのケースで最初に実行されたアクションからロックされることを意味します。つまり、ロックは残りのトランザクションを通じて保持されます。 ケースが複数の並列プロセスによってアクセスされる場合、それは他のアクティビティのブロックを引き起こす可能性があります。 

同じレコードへの更新を単一の更新ステップに統合し、その後のトランザクションで、特にレコードが作成後すぐに複数の人によって激しい競合やアクセスがある場合、全体的なスケーラビリティに大きな利点があります。

同じレコードに対する更新を単一のプロセスに統合するかどうかの決定は、実装の複雑さと、個別の更新によってもたらされる競合の可能性とのバランスをとることに基づいて行われます。 しかし、ボリュームの大きいシステムでは、これは競合の激しいリソースにとって非常にメリットがあります。 

## <a name="only-update-things-you-need-to"></a>必要なものだけを更新する

有益なアクティビティを除外してアプリ用 CDS システムのメリットを減らさないことが重要ですが、ビジネス上の価値はほとんどないが技術的な複雑さを増すカスタマイズを含めるように要求されることがよくあります。
 
タスクを作成するたびに、現在割り当てられているタスクの数でユーザー レコードも更新すると、ユーザー レコードも競合する可能性があるため、二次レベルのブロックが発生する可能性があります。 必ずしもアクションにとって重要ではないにもかかわらず、それが各要求がブロックして待つ必要があるかもしれない別のリソースを追加するでしょう。 その例では、ユーザーに対するタスクの数を格納することが重要であるのか、それともオンデマンドで計算できるのか、アプリ用 CDS の階層およびロールアップ フィールド機能をネイティブで使用するといったような別の場所に格納できるのかどうかを慎重に検討してください。 

![不要な更新を示す問題の例](media/only-update-things-you-need-to.png)

後で示すように、システム ユーザー レコードを更新すると、スケーラビリティの観点から悪影響が出る可能性があります。 

## <a name="multiple-customizations-triggered-on-same-event"></a>同じイベントでトリガーされた複数のカスタマイズ

同じイベントで複数のアクションをトリガーすると、リクエストの性質上、これらのアクションが同じ関連オブジェクトまたは親オブジェクトと対話する可能性が高いため、衝突の可能性が高くなります。

![同じイベントでトリガーされた複数のカスタマイズ](media/multiple-triggers-on-same-event.png)

これは、慎重に検討または回避する必要があるパターンです。特に異なる人が異なるプロセスを実装するときには、競合を見落としがちなためです。

## <a name="when-to-use-different-types-of-customization"></a>異なる種類のカスタマイズを使用する場合

カスタマイズの種類ごとに、使用方法が異なります。 次の表は、それぞれを考慮して使用する必要がある場合、および使用に適していない場合の一般的なパターンをまとめたものです。

さまざまな動作間の妥協点を検討する必要がある場合が多いので、これにより、考慮すべきいくつかの共通の特性とシナリオについてのガイダンスが得られますが、各シナリオを評価し、すべての関連要因に基づいて適切なアプローチを選択する必要があります。

|前 / 後 ステージ|同期 / 非同期|カスタマイズの種類|を使用する場合|when_not_to_use_dmm|
|--|--|--|--|--|
|事前検証|Sync|プラグイン|入力値の短期検証|長期実行アクション。<br /><br />後のステップが失敗した場合にロールバックする必要がある関連アイテムを作成するとき。|
|事前操作|Sync|ワークフロー / プラグイン|入力値の短期検証<br /><br />プラットフォームのステップの失敗の一部としてロールバックする必要がある関連アイテムを作成するとき。|長期実行アクション。<br /><br />アイテムとその GUID を作成するには、項目に対して保存する必要があるときに、プラットフォームを作成 / 更新します。|
|事後操作 |Sync|ワークフロー / プラグイン|プラットフォームのステップに通常通り従い、後のステップが失敗した場合にロールバックする必要がある短期間のアクション (たとえば、新しく作成されたアカウントの所有者に対するタスクの作成)。<br /><br />作成したアイテムの GUID を必要とし、失敗した場合にプラットフォームのステップをロールバックする必要がある関連アイテムの作成|長期実行アクション。<br /><br />失敗がプラットフォーム パイプラインのステップの完了に影響を及ぼさないようにします。|
|イベント パイプラインには無し|同期|ワークフロー / プラグイン|ユーザー エクスペリエンスに影響を与えると思われる中程度の長さのアクション。<br /><br />失敗した場合にロールバックできないアクション。<br /><br />失敗時にプラットフォームのステップのロールバックを強制するべきではないアクション。|非常に長い時間実行されているアクション。<br /><br />これらは、アプリ用 CDS で管理するべきではありません。<br /><br />非常にコストの低いアクション。 非常にコストの低いアクションに対して非同期な振る舞いを生成することによるオーバーヘッドは、非常に大きくなる可能性があります。可能であれば、これらを同期的に行い、非同期処理のオーバーヘッドを避けてください。|
|該当なし<br />呼び出された場所のコンテキストを取ります。||ユーザー定義アクション|Web リソースなどの外部ソースから起動されたアクションの組み合わせ|常にプラットフォーム イベントに応答してトリガーする場合は、プラグイン / ワークフローを使用してください。|

## <a name="plug-insworkflows-arent-batch-processing-mechanisms"></a>プラグイン / ワークフローはバッチ処理メカニズムではありません

長時間実行されるアクションや大量のアクションは、プラグインやワークフローからの実行を想定していません。 アプリ用 CDS は、計算プラットフォームとしての使用を想定したものではありません。特に、関連性のない大規模なアップデートを押し進めるコントローラーとしての使用は想定していません。

それを行う必要がある場合は、Azure ワーカー ロールなどの別のサービスからオフロードして実行します。 

## <a name="setting-up-security"></a>セキュリティ設定

非常に一般的なエスカレーション領域は、セキュリティ設定のスケーラビリティです。 これはコストのかかる操作なので、理解なく慎重に検討せず大量に行うと、問題が発生する可能性が常にあります。 

### <a name="team-setup"></a>チーム セットアップ

- 常に同じ順序でユーザーを追加します。次の方法でデッドロックを回避します。
- 更新が必要な場合にのみユーザーを更新します。不必要にユーザーのキャッシュを無効にしないようにします。

### <a name="owner-v-access-teams"></a>所有者 v。  アクセス チーム

- ユーザーのチームが定期的に変わる場合は、所有者チームの頻繁な使用は注意してください。変更するたびに、Web サーバーのユーザー キャッシュが無効になります
- 理想としては、夜間といったようなユーザーが作業をしていないときに変更を加え、影響を軽減します。

### <a name="lots-of-team-memberships-bus"></a>たくさんのチーム メンバーシップ / BU

- 多数のチーム / BU が複雑な計算を追加するシナリオを慎重に検討してください。

### <a name="cascading-behavior"></a>カスケード動作

- 割り当てなど、カスケード共有を検討する

### <a name="careful-updating--of-user-records"></a>ユーザー レコードの慎重な更新

- 基本的な部分の変更がない限り、システム ユーザー レコードを定期的に更新しないでください。ユーザー キャッシュが強制的にリロードされ、セキュリティ特権が再計算されるため、負荷のかかる作業となります
- 例えば、システム ユーザーを使用して、そのユーザーのオープン アクティビティの数を記録しないようにしてください

## <a name="diagram-related-actions"></a>ダイアグラム関連のアクション

予防策として、またブロックの問題を診断するためのツールとして非常に有益なアクティビティは、アプリ用 CDS プラットフォームでトリガーされる関連アクションを図にすることです。 これを行うことは、システム内の意図的および意図的でない依存関係とトリガーの両方を強調するのに役立ちます。 解決するために、これができない場合、実装が実際のところ何をするかについての明確な像が、自分の中で描けていない可能性があります。 意図しない結果を明らかにすることができるので、実装時にそのような図を作成することをお勧めします。 

次の例では、最初は 2 つのプロセスがどのように完璧に連携して動作するのかを強調していますが、継続的なメンテナンスでタスクを作成するための新しい手順を追加すると意図しないループが発生する可能性があります。 このドキュメントにある方法を使用すると、設計段階でこれが強調され、システムへ影響を与えないようにすることができます。

![ダイアグラム関連のアクション](media/diagram-related-actions.png)

<!-- NOTE: Excluding content on isolation modes and transaction diagnosis as it is for on-premises only. -->

## <a name="review-system-captured-statistics"></a>システムが取得した統計情報を確認する

問題がデータベース レイヤーの外側で発生した場合、何が起きているのかを判断する方法がいくつかあります。 1 つ目はプラグイン パフォーマンスの分析です。 [PluginTypeStatistic エンティティ](../reference/entities/plugintypestatistic.md) でクエリを実行して、プラグインが実行されている頻度と、実行にかかる時間の統計を表示できます。

特定のエラーが発生している場合は、サーバーのトレース ファイルを使用して、関連する問題がプラットフォーム内のどこで発生している可能性があるのか知る際にも便利です。 詳細: [トレースの使用](../debug-plug-in.md#use-tracing)

## <a name="summary"></a>概要

[アプリ用 Common Data Service でのスケーラブル カスタマイズ設計](overview.md) の内容とそれに続くトピック [データベースのトランザクション](database-transactions.md)、[同時実行の問題](concurrency-issues.md)、このトピックでは、次の概念と、アプリ用 CDS のスケーラブルなカスタマイズを設計および実装する方法を理解するのに役立つ例と方法を紹介しました。

覚えておくべきいくつかの重要なことは次のとおりです。 

### <a name="locks-transactions"></a>ロック / トランザクション

- ロックとトランザクションは、健全なシステムにとって不可欠です
- しかし、誤って使用すると、問題が発生する可能性があります

### <a name="platform-constraints"></a>プラットフォームの制約

- プラットフォームの制約はしばしばエラーの形で現れます
- しかし、制約が問題の原因であることはめったにありません
- プラットフォームや他のアクティビティが影響を受けないよう、保護するために存在します

### <a name="design-for-transaction-use"></a>トランザクション用の設計

- 実装がトランザクションの動作を念頭に置いて設計されている場合、これにより、はるかに高いスケーラビリティとユーザー パフォーマンスの向上がもたらされます
